<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DDP Supply Chain Graph v5</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Manrope:wght@500;600;700;800&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="styles.css" />
    <script src="https://unpkg.com/cytoscape@3.30.2/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
  </head>
  <body>
    <header class="top-header">
      <div class="brand-lockup">
        <div class="brand-title-row">
          <strong>DDP Supply Chain Command Graph</strong>
          <span class="header-version">v5</span>
        </div>
        <small class="brand-subtitle">Executive dependency intelligence with scenario context</small>
      </div>
      <small id="kpi" class="kpi">loading&hellip;</small>
    </header>

    <section class="control-bar">
      <div class="control-cluster control-mode">
        <span class="cluster-label">View</span>
        <div class="mode-toggle" id="modeToggle">
          <button class="mode-btn active" data-mode="executive">Executive</button>
          <button class="mode-btn" data-mode="analyst">Analyst</button>
        </div>
      </div>
      <div class="control-cluster control-search">
        <span class="cluster-label">Search</span>
        <input id="search" placeholder="Node, id, or company" />
      </div>
      <div class="control-cluster">
        <span class="cluster-label">Gate</span>
        <select id="gateFilter">
          <option value="all">All</option>
          <option value="true">Pass</option>
          <option value="false">Fail</option>
          <option value="unknown">Unknown</option>
        </select>
      </div>
      <div class="control-cluster">
        <span class="cluster-label">Confidence</span>
        <select id="confFilter">
          <option value="all">All</option>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
        </select>
      </div>
      <div class="control-cluster">
        <span class="cluster-label">Scenario</span>
        <select id="scenarioMode">
          <option value="base">Base</option>
          <option value="bull">Bull</option>
          <option value="bear">Bear</option>
        </select>
      </div>
      <div class="control-cluster control-toggle">
        <label class="toggle-switch">
          <input type="checkbox" id="companyToggle" />
          <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label" id="companyToggleLabel">Company overlay (0)</span>
      </div>
      <div class="control-cluster control-actions">
        <button id="showTop10">Top Bottlenecks</button>
        <button id="reset">Reset</button>
      </div>
    </section>

    <section class="idea-strip-wrap">
      <div class="idea-strip-title">Candidate Paths</div>
      <div id="spotlightButtons" class="spotlight-group"></div>
    </section>

    <main>
      <div class="graph-wrap">
        <div id="cy"></div>
      </div>
      <aside id="panel">
        <div class="card detail-card">
          <div class="card-header">Details</div>
          <div id="details"><small>Select a node to inspect risk profile, dependencies, and linked companies.</small></div>
        </div>
        <div class="card legend-card">
          <details>
            <summary>Legend</summary>
            <div class="legend">
              <div class="legend-item"><span class="legend-swatch roundrect" style="background:#f0f3f7;border:1px solid #9baaba"></span> L1 anchor</div>
              <div class="legend-item"><span class="legend-swatch circle" style="background:#c8cdd6;border:1px solid #8b95a5"></span> Component</div>
              <div class="legend-item"><span class="legend-swatch diamond" style="background:#8492a6"></span> Company</div>
            </div>
            <div class="legend-section">Gate status (fill)</div>
            <div class="legend">
              <div class="legend-item"><span class="legend-swatch circle" style="background:#b5dcc6;border:1px solid #4daa72"></span> Pass</div>
              <div class="legend-item"><span class="legend-swatch circle" style="background:#e8a0a0;border:1px solid #c24040"></span> Fail</div>
              <div class="legend-item"><span class="legend-swatch circle" style="background:#c8cdd6;border:1px solid #8b95a5"></span> Unknown</div>
            </div>
            <div class="legend-section">Confidence (opacity)</div>
            <div class="legend">
              <div class="legend-item"><span class="legend-swatch circle" style="background:#6882a0;opacity:1.0"></span> High</div>
              <div class="legend-item"><span class="legend-swatch circle" style="background:#6882a0;opacity:0.72"></span> Med</div>
              <div class="legend-item"><span class="legend-swatch circle" style="background:#6882a0;opacity:0.48"></span> Low</div>
            </div>
            <div class="legend-section">Size = 4 discrete risk tiers</div>
          </details>
        </div>
      </aside>
    </main>

    <script type="module">
      import { loadElements, loadCompanyOverlay, loadCompanyRollupL1, loadCompanyRollupL2, SPOTLIGHT_PATHS } from './graph_data.js';

      /* ── DOM refs ── */
      const details             = document.getElementById('details');
      const searchEl            = document.getElementById('search');
      const gateEl              = document.getElementById('gateFilter');
      const confEl              = document.getElementById('confFilter');
      const scenarioEl          = document.getElementById('scenarioMode');
      const kpiEl               = document.getElementById('kpi');
      const companyToggleEl     = document.getElementById('companyToggle');
      const companyToggleLabelEl = document.getElementById('companyToggleLabel');

      let currentMode          = 'executive';
      let activeSpotlight      = null;
      let companyOverlayActive = false;
      let allNodes  = [];
      let allEdges  = [];
      let companyOverlay = { nodes: [], edges: [] };
      let companyRollupL1 = {};
      let companyRollupL2 = {};
      const companyRollupByL1NodeId = new Map();
      const companyRollupByL2NodeId = new Map();

      /* ── Utility ── */
      function gateClass(v) {
        if (v === true  || v === 'true')  return 'pass';
        if (v === false || v === 'false') return 'fail';
        return 'unknown';
      }
      function escHtml(s) {
        const d = document.createElement('div');
        d.textContent = s;
        return d.innerHTML;
      }
      function fmtScenario(s) {
        if (!s || typeof s !== 'object') return String(s || 'n/a');
        const parts = [];
        if (s.tariff_penalty_pct != null) parts.push('tariff ' + s.tariff_penalty_pct + '%');
        if (s.regulatory_delay_weeks != null) parts.push('delay ' + s.regulatory_delay_weeks + 'w');
        if (s.narrative) parts.push(s.narrative.slice(0, 100));
        return parts.join(' \u00b7 ') || 'n/a';
      }

      /* ── Load data ── */
      try {
        const elements = await loadElements();
        allNodes = elements.filter(el => !el.data.source);
        allEdges = elements.filter(el => el.data.source);
      } catch (err) {
        const hint = location.protocol === 'file:'
          ? 'Opened via file://. Use a local server so fetch() can load data files.'
          : 'Failed to load graph data. Serve project root and open /presentation/cytoscape/.';
        document.getElementById('cy').innerHTML =
          `<div style="padding:20px;color:#f97066">Graph load failed.<br><small>${hint}</small><br><small>${String(err.message||err)}</small></div>`;
        throw err;
      }

      try {
        companyOverlay = await loadCompanyOverlay();
        companyToggleLabelEl.textContent = `Company overlay (${companyOverlay.nodes.length})`;
      } catch (err) {
        console.warn('Company overlay load failed:', err);
        companyToggleEl.disabled = true;
        companyToggleLabelEl.textContent = 'Company overlay unavailable';
      }

      try {
        companyRollupL1 = await loadCompanyRollupL1();
        const byNode = companyRollupL1.by_l1_node_id || {};
        Object.entries(byNode).forEach(([nodeId, rec]) => companyRollupByL1NodeId.set(nodeId, rec));
      } catch (err) {
        console.warn('L1 company rollup load failed:', err);
      }

      try {
        companyRollupL2 = await loadCompanyRollupL2();
        const byNode = companyRollupL2.by_l2_node_id || {};
        Object.entries(byNode).forEach(([nodeId, rec]) => companyRollupByL2NodeId.set(nodeId, rec));
      } catch (err) {
        console.warn('L2 company rollup load failed:', err);
      }

      /* ── Company indexes for detail panel ── */
      const companyEdgesByComponent = new Map();
      const companyNodeById = new Map();
      for (const cn of companyOverlay.nodes) companyNodeById.set(cn.data.id, cn.data);
      for (const ce of companyOverlay.edges) {
        const src = ce.data.source;
        if (!companyEdgesByComponent.has(src)) companyEdgesByComponent.set(src, []);
        companyEdgesByComponent.get(src).push(ce.data);
      }

      /* ── Visible elements for current mode ── */
      function getVisibleElements() {
        const nodes = currentMode === 'executive'
          ? allNodes.filter(n => n.data.visibility === 'executive')
          : allNodes;
        nodes.sort((a, b) => String(a.data.id || '').localeCompare(String(b.data.id || '')));
        const nodeIds = new Set(nodes.map(n => n.data.id));
        const edges = allEdges.filter(
          e => nodeIds.has(e.data.source) && nodeIds.has(e.data.target)
        );
        edges.sort((a, b) => String(a.data.id || '').localeCompare(String(b.data.id || '')));
        return [...nodes, ...edges];
      }

      /* ─────────────────────────────────────────────────────
         Final Beauty Pass — polished light-modern palette
         Composition-first with semantic color and strong hierarchy.
         ───────────────────────────────────────────────────── */

      /* Confidence — slightly wider range for better differentiation */
      function confOpacity(ele) {
        const c = (ele.data('confidence') || '').toLowerCase();
        if (c.includes('high'))   return 1.0;
        if (c.includes('medium')) return 0.72;
        return 0.48;
      }

      /* Label visibility — L1/L2/L3 readable, L4 hidden until hover */
      function labelOpacity(ele) {
        const layer = String(ele.data('layer') || '').toUpperCase();
        if (layer === 'L1') return 1;
        if (layer === 'L2') return 0.92;
        if (layer === 'L3') {
          const tier = Number(ele.data('bottleneck_tier')) || 0;
          if (tier >= 3) return 0.88;
          if (tier >= 2) return 0.72;
          return 0.52;
        }
        if ((Number(ele.data('bottleneck_tier')) || 0) >= 3) return 0.74;
        return 0.14;
      }

      /* Fill — semantic colors: green pass, coral fail, slate unknown */
      function nodeFill(ele) {
        const nt = (ele.data('node_type') || '').toLowerCase();
        if (nt === 'company')                 return '#8492a6';
        if (nt.includes('l1'))                return '#f0f3f7';
        if (nt === 'source' || nt === 'gap')  return '#cdd4de';
        const p = ele.data('gate_pass');
        if (p === true  || p === 'true')      return '#b5dcc6';

        if (p === false || p === 'false')     return '#e8a0a0';
        return '#c8cdd6';
      }

      /* Border — clean semantic ring */
      function nodeBorder(ele) {
        const nt = (ele.data('node_type') || '').toLowerCase();
        if (nt === 'company')                 return '#5c6b7f';
        if (nt.includes('l1'))                return '#9baaba';
        if (nt === 'source' || nt === 'gap')  return '#b0b8c4';
        const p = ele.data('gate_pass');
        if (p === true  || p === 'true')      return '#4daa72';
        if (p === false || p === 'false')     return '#c24040';
        return '#8b95a5';
      }

      const cyStyles = [
        /* ── Base node ── */
        {
          selector: 'node',
          style: {
            'label':              'data(short_label)',
            'text-wrap':          'wrap',
            'text-max-width':     ele => {
              const layer = String(ele.data('layer') || '').toUpperCase();
              if (layer === 'L1') return 130;
              if (layer === 'L2') return 105;
              return 86;
            },
            'font-size':          10,
            'font-family':        '"Inter", system-ui, -apple-system, sans-serif',
            'font-weight':        600,
            'color':              '#1a2332',
            'text-outline-color': '#f5f6f9',
            'text-outline-width': 2.0,
            'text-background-color': '#f4f5f8',
            'text-background-opacity': 0.78,
            'text-background-shape': 'roundrectangle',
            'text-background-padding': 2,
            'text-valign':        'bottom',
            'text-margin-y':      7,
            'text-opacity':       labelOpacity,
            'background-color':   nodeFill,
            'border-width':       ele => {
              const nt = (ele.data('node_type') || '').toLowerCase();
              if (nt === 'source' || nt === 'gap') return 0.5;
              if (nt.includes('l1')) return 1.6;
              return 1.1;
            },
            'border-color':       nodeBorder,
            'width':              'data(node_w)',
            'height':             'data(node_h)',
            'shape':              ele => {
              const nt = (ele.data('node_type') || '').toLowerCase();
              if (nt === 'company')  return 'diamond';
              if (nt.includes('l1')) return 'round-rectangle';
              return 'ellipse';
            },
            'opacity':            confOpacity,
            'overlay-padding':    3,
            'overlay-opacity':    0
          }
        },

        /* ── L1 capsule anchors — centered label, bold type ── */
        {
          selector: 'node[node_type = "l1_domain"], node[node_type = "l1_component"]',
          style: {
            'font-family':        '"Manrope", "Inter", system-ui, sans-serif',
            'font-size':          11.5,
            'font-weight':        800,
            'color':              '#1a2332',
            'text-outline-width': 2.4,
            'text-background-opacity': 0.92,
            'text-valign':        'center',
            'text-margin-y':      0
          }
        },
        {
          selector: 'node[layer = "L2"]',
          style: {
            'font-size': 9.5,
            'font-weight': 600,
            'text-background-opacity': 0.72
          }
        },
        {
          selector: 'node[layer = "L3"]',
          style: {
            'font-size': 8.5,
            'font-weight': 560,
            'text-background-opacity': 0.58,
            'text-margin-y': 6
          }
        },

        /* ── Source / gap — contextual satellite dots ── */
        {
          selector: 'node[node_type = "source"], node[node_type = "gap"]',
          style: {
            'font-size': 0,
            'opacity':   0.32
          }
        },

        /* ── Company — small, quiet ── */
        {
          selector: 'node[node_type = "company"]',
          style: {
            'font-size':  8,
            'font-weight': 500,
            'color':      '#5c6b7f'
          }
        },

        /* ── Tier-3 bottleneck accent — bold ring ── */
        {
          selector: 'node[bottleneck_tier = 3]',
          style: {
            'border-width': 2.2,
            'border-color': '#c24040'
          }
        },

        /* ── Edge hierarchy ── */
        {
          selector: 'edge',
          style: {
            'curve-style':        'bezier',
            'target-arrow-shape': 'triangle',
            'arrow-scale':        0.68,
            'line-color':         '#a0aab8',
            'target-arrow-color': '#a0aab8',
            'width':              1.0,
            'opacity':            0.52,
            'line-style':         'solid'
          }
        },
        {
          selector: 'edge[dependency_type = "decomposes_to"]',
          style: {
            'line-color':         '#6882a0',
            'target-arrow-color': '#6882a0',
            'width':              1.7,
            'opacity':            0.78
          }
        },
        {
          selector: 'edge[dependency_type = "constrained_by_gap"]',
          style: {
            'line-color':         '#c87a5a',
            'target-arrow-color': '#c87a5a',
            'width':              1.4,
            'opacity':            0.68,
            'line-style':         'solid'
          }
        },
        {
          selector: 'edge[dependency_type = "evidenced_by"]',
          style: {
            'line-color':         '#b4bcc8',
            'target-arrow-color': '#b4bcc8',
            'line-style':         'dashed',
            'width':              0.8,
            'opacity':            0.30
          }
        },
        {
          selector: 'edge[dependency_type = "depends_on_company"], edge[dependency_type = "supplied_by"]',
          style: {
            'line-color':         '#9ba5b4',
            'target-arrow-color': '#9ba5b4',
            'line-style':         'dotted',
            'width':              0.7,
            'opacity':            0.26
          }
        },

        /* ── Hover — label reveal ── */
        {
          selector: '.hover',
          style: {
            'text-opacity':    1,
            'font-weight':     700,
            'overlay-opacity': 0
          }
        },

        /* ── State classes (order = priority) ── */
        { selector: '.dim', style: {
          'opacity': 0.06, 'text-opacity': 0
        }},
        { selector: '.top10', style: {
          'opacity': 1, 'text-opacity': 1,
          'border-width': 2.4, 'border-color': '#3b6fb5',
          'overlay-opacity': 0
        }},
        { selector: '.spotlight', style: {
          'opacity': 1, 'text-opacity': 1,
          'border-width': 2.4, 'overlay-opacity': 0
        }},
        { selector: '.spotlight-1', style: { 'border-color': '#3b6fb5' } },
        { selector: '.spotlight-2', style: { 'border-color': '#6e5ba8' } },
        { selector: '.spotlight-3', style: { 'border-color': '#a67c20' } },
        { selector: '.spotlight-edge', style: {
          'opacity': 0.82, 'width': 2.0,
          'line-color': '#3b6fb5', 'target-arrow-color': '#3b6fb5'
        }},
        /* Focus — refined blue border + slight scale */
        { selector: '.focus', style: {
          'opacity': 1, 'text-opacity': 1,
          'width': 'data(node_w_focus)', 'height': 'data(node_h_focus)',
          'border-width': 2.8, 'border-color': '#3b6fb5',
          'overlay-opacity': 0
        }},
        { selector: '.focus-context', style: {
          'opacity': 0.88, 'text-opacity': 1,
          'border-width': 1.6, 'border-color': '#6882a0',
          'overlay-opacity': 0
        }},
        { selector: '.focus-edge', style: {
          'opacity': 0.88, 'width': 1.8,
          'line-color': '#3b6fb5', 'target-arrow-color': '#3b6fb5'
        }}
      ];

      /* ── Cytoscape init ── */
      const cy = cytoscape({
        container: document.getElementById('cy'),
        elements: getVisibleElements(),
        layout: { name: 'preset' },
        style: cyStyles
      });

      /* ── Layout ── */
      function layerRank(node) {
        const layer = String(node.data('layer') || '').toUpperCase();
        if (layer === 'L1') return 1;
        if (layer === 'L2') return 2;
        if (layer === 'L3') return 3;
        return 4;
      }

      function laneKeyForNode(node) {
        const direct = (node.data('l1_component') || '').trim();
        if (direct) return direct;
        const id = String(node.id() || '');
        if (id.startsWith('n_l1_')) return id.slice('n_l1_'.length);
        return 'other';
      }

      function hash01(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return ((h >>> 0) % 10000) / 10000;
      }

      function clamp(n, lo, hi) {
        return Math.max(lo, Math.min(hi, n));
      }

      /* ── Multi-band domain cluster layout (beauty pass) ── */
      function applyDomainClusterLayout() {
        const graphW = cy.width();
        const graphH = cy.height();

        /* read dagre x to preserve left-right ordering */
        const xOrder = new Map();
        cy.nodes().forEach(n => xOrder.set(n.id(), n.position('x')));

        /* group by domain */
        const domMap = new Map();
        cy.nodes().forEach(n => {
          const key = laneKeyForNode(n);
          if (!domMap.has(key)) domMap.set(key, []);
          domMap.get(key).push(n);
        });

        /* sort domains by average dagre-x to maintain narrative order */
        const domains = [...domMap.entries()].sort((a, b) => {
          const ax = a[1].reduce((s, n) => s + (xOrder.get(n.id()) || 0), 0) / a[1].length;
          const bx = b[1].reduce((s, n) => s + (xOrder.get(n.id()) || 0), 0) / b[1].length;
          return ax - bx;
        });

        const nd = domains.length;
        const mx = 48, my = 40;
        const usableW = Math.max(400, graphW - 2 * mx);
        const usableH = Math.max(260, graphH - 2 * my);
        const domainSpan = clamp(usableW / Math.max(2, nd * 0.85), 148, 260);
        const waveAmp = Math.min(usableH * 0.13, 78);
        const yMidBase = my + usableH * 0.48;

        cy.startBatch();

        domains.forEach(([key, allNodes], idx) => {
          const t = nd <= 1 ? 0.5 : idx / (nd - 1);
          const cx = mx + t * usableW;
          /* gentler wave — sinusoidal offset for organic stagger */
          const cyPos = yMidBase + Math.sin((t * Math.PI * 1.8) + 0.5) * waveAmp;
          const bandH = clamp(usableH * 0.66, 230, 360);

          const l1 = allNodes.filter(n => String(n.data('layer') || '').toUpperCase() === 'L1');
          const l2 = allNodes.filter(n => String(n.data('layer') || '').toUpperCase() === 'L2')
            .sort((a, b) => (xOrder.get(a.id()) || 0) - (xOrder.get(b.id()) || 0));
          const l3 = allNodes.filter(n => String(n.data('layer') || '').toUpperCase() === 'L3')
            .sort((a, b) => (xOrder.get(a.id()) || 0) - (xOrder.get(b.id()) || 0));
          const l4 = allNodes.filter(n => {
            const nt = (n.data('node_type') || '').toLowerCase();
            return nt === 'source' || nt === 'gap';
          });
          const co = allNodes.filter(n => (n.data('node_type') || '') === 'company');
          const untyped = allNodes.filter(n => {
            const layer = String(n.data('layer') || '').toUpperCase();
            const nt = String(n.data('node_type') || '').toLowerCase();
            return layer !== 'L1' && layer !== 'L2' && layer !== 'L3' && nt !== 'source' && nt !== 'gap' && nt !== 'company';
          }).sort((a, b) => (xOrder.get(a.id()) || 0) - (xOrder.get(b.id()) || 0));
          const l3All = l3.concat(untyped);

          /* L1 — domain anchor at top of cell */
          l1.forEach(n => n.position({ x: cx, y: cyPos - bandH * 0.42 }));

          /* L2 — fan arc below L1 with organic jitter */
          if (l2.length) {
            const span = domainSpan * 0.96;
            const yCenter = cyPos - bandH * 0.16;
            const arcDip = Math.min(18, l2.length * 3);
            l2.forEach((n, i) => {
              const frac = l2.length <= 1 ? 0.5 : i / (l2.length - 1);
              const arcY = arcDip * (4 * (frac - 0.5) * (frac - 0.5));
              n.position({
                x: cx - span / 2 + span * frac + (hash01(`${n.id()}_l2x`) - 0.5) * 10,
                y: yCenter + arcY + (hash01(`${n.id()}_l2y`) - 0.5) * 8
              });
            });
          }

          /* L3 – staggered rows with tighter clustering and diagonal offset */
          if (l3All.length) {
            const maxPerRow = Math.max(2, Math.ceil(Math.sqrt(l3All.length * 2.0)));
            const nRows = Math.ceil(l3All.length / maxPerRow);
            const xSpan = domainSpan * 1.06;
            const yStart = cyPos + bandH * 0.0;
            const yEnd   = cyPos + bandH * 0.28;
            const ySpan = yEnd - yStart;

            l3All.forEach((n, i) => {
              const r = Math.floor(i / maxPerRow);
              const c = i % maxPerRow;
              const inRow = Math.min(maxPerRow, l3All.length - r * maxPerRow);
              const frac = inRow <= 1 ? 0.5 : c / (inRow - 1);
              /* alternating row offset for brick-like stagger */
              const stagger = (r % 2 === 1 && inRow > 1) ? (xSpan / maxPerRow) * 0.42 : 0;
              const yFrac = nRows <= 1 ? 0.5 : r / (nRows - 1);
              n.position({
                x: cx - xSpan / 2 + xSpan * frac + stagger + (hash01(`${n.id()}_l3x`) - 0.5) * 10,
                y: yStart + ySpan * yFrac + (hash01(`${n.id()}_l3y`) - 0.5) * 8
              });
            });
          }

          /* L4 — tight contextual cloud near bottom */
          if (l4.length) {
            const span = domainSpan * 0.78;
            const baseY = cyPos + bandH * 0.38;
            const perRow = 7;
            const l4Rows = Math.ceil(l4.length / perRow);
            l4.forEach((n, i) => {
              const r = Math.floor(i / perRow);
              const c = i % perRow;
              const inRow = Math.min(perRow, l4.length - r * perRow);
              const x = inRow > 1 ? cx - span / 2 + span * c / (inRow - 1) : cx;
              const yOff = l4Rows > 1 ? (bandH * 0.10) * r / (l4Rows - 1) : 0;
              n.position({
                x: x + (hash01(n.id()) - 0.5) * 5,
                y: baseY + yOff + (hash01(n.id() + 'y') - 0.5) * 5
              });
            });
          }

          /* Company – compact band tucked below L3 */
          if (co.length) {
            const span = domainSpan * 0.68;
            const baseY = cyPos + bandH * 0.24;
            co.forEach((n, i) => {
              const x = co.length > 1 ? cx - span / 2 + span * i / (co.length - 1) : cx;
              n.position({
                x: x + (hash01(n.id()) - 0.5) * 6,
                y: baseY + (hash01(n.id() + 'y') - 0.5) * 9
              });
            });
          }
        });

        cy.endBatch();
      }

      /* ── Collision resolution: push overlapping nodes apart ── */
      function resolveCollisions(iterations) {
        const nodes = cy.nodes().toArray();
        const n = nodes.length;
        for (let iter = 0; iter < iterations; iter++) {
          let moved = false;
          cy.startBatch();
          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              const a = nodes[i], b = nodes[j];
              const ax = a.position('x'), ay = a.position('y');
              const bx = b.position('x'), by = b.position('y');
              const dx = bx - ax, dy = by - ay;
              const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
              const aw = (a.data('node_w') || 20), bw = (b.data('node_w') || 20);
              const ah = (a.data('node_h') || 20), bh = (b.data('node_h') || 20);
              const minDist = (aw + bw) / 2 + 16;
              if (dist < minDist) {
                const push = (minDist - dist) * 0.28;
                const ux = dx / dist, uy = dy / dist;
                a.position({ x: ax - ux * push, y: ay - uy * push });
                b.position({ x: bx + ux * push, y: by + uy * push });
                moved = true;
              }
            }
          }
          cy.endBatch();
          if (!moved) break;
        }
      }

      function occupancyPct() {
        const bb = cy.nodes(':visible').renderedBoundingBox({ includeLabels: false });
        const canvasArea = Math.max(1, cy.width() * cy.height());
        const usedArea = Math.max(1, bb.w * bb.h);
        return (usedArea / canvasArea) * 100;
      }

      function tuneViewportForDensity() {
        cy.fit(undefined, 28);
        const occ = occupancyPct();
        const zoom = cy.zoom();
        if (occ < 58) {
          const ratio = Math.min(1.28, Math.sqrt(68 / Math.max(occ, 1)));
          cy.zoom({ level: zoom * ratio, renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 } });
          cy.center();
        } else if (occ > 84) {
          const ratio = Math.max(0.82, Math.sqrt(78 / occ));
          cy.zoom({ level: zoom * ratio, renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 } });
          cy.center();
        }
      }

      function runLayout() {
        const isExec = currentMode === 'executive';
        try {
          if (isExec) {
            /* Step 1: dagre for initial rank ordering */
            cy.layout({
              name: 'dagre', rankDir: 'TB',
              ranker: 'network-simplex',
              nodeSep: 72, rankSep: 120, edgeSep: 32,
              sort: (a, b) => String(a.id() || '').localeCompare(String(b.id() || '')),
              animate: false, fit: true, padding: 34
            }).run();
            /* Step 2: multi-band domain cluster reposition */
            applyDomainClusterLayout();
            /* Step 3: push apart overlapping nodes */
            resolveCollisions(25);
            /* Step 4: fit and density tune */
            tuneViewportForDensity();
          } else {
            cy.layout({
              name:    'dagre',
              rankDir: 'LR',
              ranker:  'network-simplex',
              nodeSep: 48,
              rankSep: 132,
              edgeSep: 22,
              sort: (a, b) => String(a.id() || '').localeCompare(String(b.id() || '')),
              animate: false,
              fit: true,
              padding: 28
            }).run();
            cy.fit(undefined, 26);
          }
        } catch (e) {
          console.warn('primary layout failed, falling back to cose:', e);
          cy.layout({ name: 'cose', animate: false, fit: true, padding: 24 }).run();
        }
      }

      /* ── Rebuild graph (mode switch / company toggle) ── */
      function rebuildGraph() {
        cy.elements().remove();
        cy.add(getVisibleElements());
        if (companyOverlayActive) {
          cy.add([...companyOverlay.nodes, ...companyOverlay.edges]);
        }
        runLayout();
        applyFilters();
        updateKPI();
      }

      /* ═══════════════════════════════════════════════════
         Mode toggle
         ═══════════════════════════════════════════════════ */
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const mode = btn.dataset.mode;
          if (mode === currentMode) return;
          currentMode = mode;
          document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          clearSpotlight();
          rebuildGraph();
        });
      });

      /* ═══════════════════════════════════════════════════
         Spotlight paths (3 candidate ideas)
         ═══════════════════════════════════════════════════ */
      function buildSpotlightButtons() {
        const container = document.getElementById('spotlightButtons');
        for (const [key, path] of Object.entries(SPOTLIGHT_PATHS)) {
          const btn = document.createElement('button');
          btn.className = 'spotlight-btn';
          btn.dataset.idea = key;
          btn.innerHTML = `
            <span class="spotlight-color" style="background:${escHtml(path.color)}"></span>
            <div>
              <div class="spotlight-name">${escHtml(path.label)}</div>
              <div class="spotlight-desc">${escHtml(path.description)}</div>
            </div>`;
          btn.addEventListener('click', () => toggleSpotlight(key));
          container.appendChild(btn);
        }
      }

      function toggleSpotlight(ideaKey) {
        if (activeSpotlight === ideaKey) { clearSpotlight(); return; }
        clearSpotlight();
        activeSpotlight = ideaKey;
        const path     = SPOTLIGHT_PATHS[ideaKey];
        const classNum = ideaKey.replace('idea_', '');

        // Match nodes by thesis_tag
        const matchNodes = cy.nodes().filter(n => n.data('thesis_tag') === ideaKey);

        // Include L1 parent nodes
        const l1Ids = new Set();
        matchNodes.forEach(n => {
          const l1 = n.data('l1_component');
          if (l1) l1Ids.add('n_l1_' + l1);
        });
        const l1Nodes = cy.nodes().filter(n => l1Ids.has(n.id()));

        const spotlightNodes = matchNodes.union(l1Nodes);
        const spotlightEdges = spotlightNodes.edgesWith(spotlightNodes);

        // Dim everything, then light up the path
        cy.elements().addClass('dim');
        spotlightNodes.removeClass('dim').addClass('spotlight spotlight-' + classNum);
        spotlightEdges.removeClass('dim').addClass('spotlight-edge');

        // Button state
        document.querySelectorAll('.spotlight-btn').forEach(b => {
          b.classList.toggle('active', b.dataset.idea === ideaKey);
        });

        // Detail panel summary
        const nodeList = matchNodes
          .sort((a, b) => (b.data('bottleneck_score') || 0) - (a.data('bottleneck_score') || 0))
          .map(n => escHtml(n.data('label')) + ' (' + (n.data('bottleneck_score') ?? '?') + ')')
          .join(', ');
        details.innerHTML = `
          <div class="detail-title">${escHtml(path.label)}</div>
          <div class="detail-note">${escHtml(path.description)}</div>
          <div class="detail-metric-row">
            <span>${spotlightNodes.length} nodes</span>
            <span>${spotlightEdges.length} edges</span>
          </div>
          <div class="detail-note">${nodeList || 'No matching nodes in current view.'}</div>
          <div class="detail-note">Click a highlighted node for full details.</div>`;
      }

      function clearSpotlight() {
        activeSpotlight = null;
        cy.elements().removeClass('dim spotlight spotlight-1 spotlight-2 spotlight-3 spotlight-edge');
        document.querySelectorAll('.spotlight-btn').forEach(b => b.classList.remove('active'));
      }

      function clearFocusClasses() {
        cy.elements().removeClass('focus focus-context focus-edge');
      }

      /* ═══════════════════════════════════════════════════
         Filters (search, gate, confidence)
         ═══════════════════════════════════════════════════ */
      function applyFilters() {
        const q    = (searchEl.value || '').trim().toLowerCase();
        const gate = gateEl.value;
        const conf = confEl.value;

        // Don't override spotlight dimming
        if (activeSpotlight) return;

        cy.elements().removeClass('dim');

        cy.nodes().forEach(n => {
          const label = (n.data('label') || '').toLowerCase();
          const id    = (n.data('id') || '').toLowerCase();
          const isCompany = n.data('node_type') === 'company';

          if (isCompany) {
            let ok = true;
            if (q && !(label.includes(q) || id.includes(q))) ok = false;
            if (conf !== 'all') {
              const ct = String(n.data('confidence') || '').toLowerCase();
              if (!ct.includes(conf)) ok = false;
            }
            if (!ok) n.addClass('dim');
            return;
          }

          const passVal  = n.data('gate_pass');
          const passText = passVal === true ? 'true' : passVal === false ? 'false' : String(passVal || 'unknown');
          const confText = String(n.data('confidence') || '').toLowerCase();

          let ok = true;
          if (q && !(label.includes(q) || id.includes(q))) ok = false;
          if (gate !== 'all' && passText !== gate)          ok = false;
          if (conf !== 'all' && !confText.includes(conf))  ok = false;
          if (!ok) n.addClass('dim');
        });

        cy.edges().forEach(e => {
          if (e.source().hasClass('dim') || e.target().hasClass('dim')) e.addClass('dim');
        });
      }

      /* ═══════════════════════════════════════════════════
         KPI bar
         ═══════════════════════════════════════════════════ */
      function updateKPI() {
        const componentNodes = cy.nodes().filter(n => n.data('node_type') !== 'company');
        const total = componentNodes.length;
        const pass  = componentNodes.filter(n => n.data('gate_pass') === true  || n.data('gate_pass') === 'true').length;
        const fail  = componentNodes.filter(n => n.data('gate_pass') === false || n.data('gate_pass') === 'false').length;
        const coCount = cy.nodes().filter(n => n.data('node_type') === 'company').length;
        const modeLabel = currentMode === 'executive' ? 'Exec' : 'Full';
        let text = `${modeLabel} \u00b7 ${total} nodes \u00b7 ${pass} pass \u00b7 ${fail} fail`;
        if (coCount > 0) text += ` \u00b7 ${coCount} cos`;
        kpiEl.textContent = text;
      }

      /* ═══════════════════════════════════════════════════
         Event listeners
         ═══════════════════════════════════════════════════ */
      searchEl.addEventListener('input', applyFilters);
      gateEl.addEventListener('change', applyFilters);
      confEl.addEventListener('change', applyFilters);

      scenarioEl.addEventListener('change', () => {
        const mode = scenarioEl.value;
        cy.nodes().forEach(n => {
          if (n.data('node_type') === 'company') return;
          const s = mode === 'bull' ? n.data('scenario_bull')
            : mode === 'bear' ? n.data('scenario_bear')
            : n.data('scenario_base');
          n.data('scenario_active', s || 'n/a');
        });
      });

      companyToggleEl.addEventListener('change', () => {
        companyOverlayActive = companyToggleEl.checked;
        rebuildGraph();
      });

      document.getElementById('showTop10').addEventListener('click', () => {
        clearSpotlight();
        cy.nodes().removeClass('top10');
        const topNodes = cy.nodes()
          .filter(n => n.data('node_type') !== 'company')
          .sort((a, b) => (b.data('bottleneck_score') || 0) - (a.data('bottleneck_score') || 0))
          .slice(0, 10);
        topNodes.forEach(n => n.addClass('top10'));
      });

      document.getElementById('reset').addEventListener('click', () => {
        searchEl.value = '';
        gateEl.value   = 'all';
        confEl.value   = 'all';
        clearSpotlight();
        clearFocusClasses();
        cy.elements().removeClass('dim top10 hover');
        runLayout();
      });

      /* ═══════════════════════════════════════════════════
         Company HTML builder (for detail panel)
         ═══════════════════════════════════════════════════ */
      function buildTopCompaniesHtml(nodeId) {
        const nodeData = cy.getElementById(nodeId).data();
        const nt = String((nodeData && nodeData.node_type) || '').toLowerCase();

        if (nt.startsWith('l1')) {
          const rec = companyRollupByL1NodeId.get(nodeId);
          const rows = rec && Array.isArray(rec.top_companies) ? rec.top_companies : [];
          if (rows.length === 0) return '<small>No L1 rollup companies linked.</small>';
          return '<div class="company-list">' + rows.slice(0, 8).map(r => {
            const label = escHtml(r.company_name || r.company_id || 'unknown');
            const weighted = Number.isFinite(Number(r.weighted_score_sum)) ? Number(r.weighted_score_sum).toFixed(2) : 'n/a';
            const confAvg = Number(r.confidence_factor_avg);
            const conf = Number.isFinite(confAvg)
              ? (confAvg >= 0.65 ? 'high' : confAvg >= 0.4 ? 'medium' : 'low')
              : 'low';
            const cls = conf === 'high' ? 'conf-high' : conf === 'medium' ? 'conf-medium' : 'conf-low';
            const roles = Array.isArray(r.roles) ? r.roles.join(', ') : '';
            const bits = [
              roles,
              r.company_type || '',
              Number.isFinite(Number(r.component_count)) ? `components ${r.component_count}` : '',
              r.fallback_scope ? 'fallback' : ''
            ].filter(Boolean).map(escHtml).join(' \u00b7 ');
            return `<div class="company-row">
              <div><span class="company-name">${label}</span> <span class="conf-badge ${cls}">${conf}</span><br><small>${bits}</small></div>
              <span class="company-score">${weighted}</span>
            </div>`;
          }).join('') + '</div>';
        }

        if (nt.startsWith('l2')) {
          const rec = companyRollupByL2NodeId.get(nodeId);
          const rows = rec && Array.isArray(rec.top_companies) ? rec.top_companies : [];
          if (rows.length === 0) return '<small>No L2 rollup companies linked.</small>';
          return '<div class="company-list">' + rows.slice(0, 8).map(r => {
            const label = escHtml(r.company_name || r.company_id || 'unknown');
            const weighted = Number.isFinite(Number(r.weighted_score_sum)) ? Number(r.weighted_score_sum).toFixed(2) : 'n/a';
            const confAvg = Number(r.confidence_factor_avg);
            const conf = Number.isFinite(confAvg)
              ? (confAvg >= 0.65 ? 'high' : confAvg >= 0.4 ? 'medium' : 'low')
              : 'low';
            const cls = conf === 'high' ? 'conf-high' : conf === 'medium' ? 'conf-medium' : 'conf-low';
            const roles = Array.isArray(r.roles) ? r.roles.join(', ') : '';
            const bits = [
              roles,
              r.company_type || '',
              Number.isFinite(Number(r.component_count)) ? `components ${r.component_count}` : '',
              r.fallback_scope ? 'fallback' : ''
            ].filter(Boolean).map(escHtml).join(' \u00b7 ');
            return `<div class="company-row">
              <div><span class="company-name">${label}</span> <span class="conf-badge ${cls}">${conf}</span><br><small>${bits}</small></div>
              <span class="company-score">${weighted}</span>
            </div>`;
          }).join('') + '</div>';
        }

        const directEdges = companyEdgesByComponent.get(nodeId) || [];
        const l1Id = nodeData && nodeData.l1_component ? 'n_l1_' + nodeData.l1_component : null;
        const l1Edges = l1Id ? (companyEdgesByComponent.get(l1Id) || []) : [];

        const seen = new Set();
        const merged = [];
        for (const e of directEdges) { seen.add(e.target); merged.push(e); }
        for (const e of l1Edges) { if (!seen.has(e.target)) { seen.add(e.target); merged.push(e); } }
        if (merged.length === 0) return '<small>No company data linked.</small>';

        merged.sort((a, b) => (b.composite_score ?? -1) - (a.composite_score ?? -1));

        return '<div class="company-list">' + merged.slice(0, 8).map(e => {
          const co    = companyNodeById.get(e.target);
          const label = co ? escHtml(co.label) : escHtml(e.target);
          const coType = co ? escHtml(co.company_type) : '';
          const score = e.composite_score != null ? e.composite_score.toFixed(1) : 'n/a';
          const conf  = (e.confidence || 'low').toLowerCase();
          const cls   = conf === 'high' ? 'conf-high' : conf === 'medium' ? 'conf-medium' : 'conf-low';
          const dep   = escHtml(e.dependency_type || '');
          const pen   = e.confidence_penalty != null ? 'pen\u00a0' + e.confidence_penalty.toFixed(2) : '';
          const bits  = [dep, pen, coType].filter(Boolean).join(' \u00b7 ');
          return `<div class="company-row">
            <div><span class="company-name">${label}</span> <span class="conf-badge ${cls}">${conf}</span><br><small>${bits}</small></div>
            <span class="company-score">${score}</span>
          </div>`;
        }).join('') + '</div>';
      }

      /* ═══════════════════════════════════════════════════
         Component detail panel
         ═══════════════════════════════════════════════════ */
      function renderComponentDetail(node) {
        const n   = node.data();
        const cls = gateClass(n.gate_pass);

        const neighbors = node.neighborhood('node');
        const edgeCount = node.connectedEdges().length;
        const topDown   = node.outgoers('node')
          .filter(x => x.data('node_type') !== 'company')
          .sort((a, b) => (b.data('bottleneck_score') || 0) - (a.data('bottleneck_score') || 0))
          .slice(0, 3)
          .map(x => escHtml(x.data('label')) + ' (' + (x.data('bottleneck_score') ?? '?') + ')')
          .join(', ');

        const gateDisplay = (n.gate_pass === 'unknown' && String(n.node_type || '').startsWith('l1'))
          ? 'structural (aggregated)'
          : n.gate_pass;

        const nt = String(n.node_type || '').toLowerCase();
        const blockerPrimary = String(n.key_blockers || '').trim();
        const blockerFallback = nt.startsWith('l1')
          ? (n.key_blockers_l1_display || n.key_blockers_fallback || n.key_blockers_synth || '')
          : nt.startsWith('l2')
            ? (n.key_blockers_l2_display || n.key_blockers_fallback || n.key_blockers_synth || '')
            : (n.key_blockers_synth || n.key_blockers_fallback || '');
        let blockerRaw = blockerPrimary || blockerFallback;
        if (!blockerRaw && nt.startsWith('l1')) {
          const rollupRec = companyRollupByL1NodeId.get(n.id);
          blockerRaw = (rollupRec && rollupRec.l1_blocker_text) || '';
        }
        if (!blockerRaw && nt.startsWith('l2')) {
          const rollupRec = companyRollupByL2NodeId.get(n.id);
          blockerRaw = (rollupRec && rollupRec.l2_blocker_text) || '';
        }
        const blockerText = blockerRaw
          ? escHtml(String(blockerRaw).slice(0, 500))
          : 'No direct blocker text. Inspect downstream nodes.';

        const scenario = n.scenario_active || n.scenario_base;
        const scenarioText = fmtScenario(scenario);

        const cosHtml = buildTopCompaniesHtml(n.id);

        details.innerHTML = `
          <div class="detail-title">${escHtml(n.label)}</div>
          <div class="detail-badges"><span class="badge ${cls}">gate: ${gateDisplay}</span></div>
          <div class="detail-grid">
            <div class="detail-row"><span>ID</span><span>${escHtml(n.id)}</span></div>
            <div class="detail-row"><span>Type</span><span>${n.node_type || '?'}</span></div>
            <div class="detail-row"><span>Domain</span><span>${n.l1_component || 'n/a'}</span></div>
            <div class="detail-row"><span>Neighbors</span><span>${neighbors.length}</span></div>
            <div class="detail-row"><span>Edges</span><span>${edgeCount}</span></div>
            <div class="detail-row"><span>Confidence</span><span>${n.confidence || 'n/a'}</span></div>
            <div class="detail-row"><span>Bottleneck</span><span>${n.bottleneck_score ?? 'n/a'}</span></div>
            <div class="detail-row"><span>Thesis</span><span>${n.thesis_tag || 'other'}</span></div>
            <div class="detail-row"><span>Scenario</span><span>${scenarioText}</span></div>
            <div class="detail-row"><span>Capacity</span><span>${n.capacity_effective ?? 'n/a'}</span></div>
            <div class="detail-row"><span>Lead Time</span><span>${n.lead_time ?? 'n/a'}</span></div>
            <div class="detail-row"><span>Cost Uplift</span><span>${n.landed_cost_uplift_pct ?? 'n/a'}%</span></div>
            <div class="detail-row"><span>Tariff</span><span>${n.tariff_penalty_pct ?? 'n/a'}%</span></div>
          </div>
          ${topDown ? `<div class="detail-note">Downstream risk: ${topDown}</div>` : ''}
          <div class="detail-note">Blockers: ${blockerText}</div>
          <div class="detail-subsection">
            <div class="detail-subtitle">Top companies</div>
            ${cosHtml}
          </div>`;
      }

      /* ═══════════════════════════════════════════════════
         Company detail panel
         ═══════════════════════════════════════════════════ */
      function renderCompanyDetail(node) {
        const n    = node.data();
        const conf = (n.confidence || 'low').toLowerCase();
        const cls  = conf === 'high' ? 'conf-high' : conf === 'medium' ? 'conf-medium' : 'conf-low';

        const linked = node.neighborhood('node')
          .filter(x => x.data('node_type') !== 'company')
          .map(x => escHtml(x.data('label')))
          .slice(0, 10);

        details.innerHTML = `
          <div class="detail-title">${escHtml(n.label)} <span class="conf-badge ${cls}">${conf}</span></div>
          <div class="detail-badges"><span class="badge unknown">company: ${escHtml(n.company_type || 'n/a')}</span></div>
          <div class="detail-grid">
            <div class="detail-row"><span>ID</span><span>${escHtml(n.id)}</span></div>
            <div class="detail-row"><span>Components</span><span>${n.component_count ?? 'n/a'}</span></div>
            <div class="detail-row"><span>Sources</span><span>${n.source_count ?? 'n/a'}</span></div>
            <div class="detail-row"><span>Avg Score</span><span>${n.avg_composite_score ?? 'n/a'}</span></div>
            <div class="detail-row"><span>Best Score</span><span>${n.best_composite_score ?? 'n/a'}</span></div>
          </div>
          ${linked.length > 0 ? `<div class="detail-note">Linked: ${linked.join(', ')}</div>` : ''}`;
      }

      /* ═══════════════════════════════════════════════════
         Tap handlers
         ═══════════════════════════════════════════════════ */
      cy.on('tap', 'node', evt => {
        clearFocusClasses();
        const node = evt.target;
        node.addClass('focus');
        node.neighborhood('node').addClass('focus-context');
        node.connectedEdges().addClass('focus-edge');
        if (node.data('node_type') === 'company') renderCompanyDetail(node);
        else renderComponentDetail(node);
      });

      cy.on('tap', 'edge', evt => {
        clearFocusClasses();
        evt.target.addClass('focus-edge');
        evt.target.source().addClass('focus-context');
        evt.target.target().addClass('focus-context');
        const e = evt.target.data();
        const depType = e.dependency_type || 'depends_on';
        let extra = '';
        if (e.composite_score != null) {
          extra += `<small>composite: ${e.composite_score} \u00b7 penalty: ${e.confidence_penalty ?? 'n/a'}</small>`;
        }
        if (e.source_count != null) {
          extra += `<small>sources: ${e.source_count}</small>`;
        }
        details.innerHTML = `
          <div class="detail-title">Edge</div>
          <div class="detail-note">${escHtml(e.source)} \u2192 ${escHtml(e.target)}</div>
          <div class="detail-note">type: ${escHtml(depType)} \u00b7 confidence: ${e.confidence || 'n/a'}</div>
          ${extra}`;
      });

      /* ═══════════════════════════════════════════════════
         Hover: reveal labels on mouseover
         ═══════════════════════════════════════════════════ */
      cy.on('mouseover', 'node', evt => evt.target.addClass('hover'));
      cy.on('mouseout',  'node', evt => evt.target.removeClass('hover'));

      /* ── Init ── */
      buildSpotlightButtons();
      runLayout();
      window.__cy = cy;
      updateKPI();

      window.__layoutDiagnostics = function () {
        const nodes = cy.nodes(':visible');
        const edges = cy.edges(':visible');
        const canvasW = cy.width();
        const canvasH = cy.height();
        const canvasArea = Math.max(1, canvasW * canvasH);
        const bbox = nodes.renderedBoundingBox({ includeLabels: false });
        const occupiedArea = Math.max(1, bbox.w * bbox.h);
        const occupiedPct = (occupiedArea / canvasArea) * 100;

        const layerCounts = { L1: 0, L2: 0, L3: 0, L4: 0, OTHER: 0 };
        nodes.forEach(n => {
          const layer = String(n.data('layer') || '').toUpperCase();
          if (layerCounts[layer] != null) layerCounts[layer] += 1;
          else layerCounts.OTHER += 1;
        });

        const labelBoxes = [];
        nodes.forEach(n => {
          if (Number(n.style('text-opacity')) < 0.2 || Number(n.style('opacity')) < 0.18) return;
          const p = n.renderedPosition();
          const text = String(n.data('short_label') || '');
          const w = Math.max(22, text.length * 6.2);
          const h = 13;
          const y = p.y + (n.renderedHeight() * 0.5) + 8;
          labelBoxes.push({ x: p.x, y, w, h });
        });

        let labelCollisions = 0;
        for (let i = 0; i < labelBoxes.length; i++) {
          for (let j = i + 1; j < labelBoxes.length; j++) {
            const a = labelBoxes[i];
            const b = labelBoxes[j];
            const overlapX = Math.abs(a.x - b.x) < (a.w + b.w) / 2;
            const overlapY = Math.abs(a.y - b.y) < (a.h + b.h) / 2;
            if (overlapX && overlapY) labelCollisions += 1;
          }
        }

        const segs = [];
        edges.forEach(e => {
          const s = e.source();
          const t = e.target();
          if (s.id() === t.id()) return;
          const sp = s.position();
          const tp = t.position();
          segs.push({ x1: sp.x, y1: sp.y, x2: tp.x, y2: tp.y, sid: s.id(), tid: t.id() });
        });

        let crossingsEstimate = 0;
        for (let i = 0; i < segs.length; i++) {
          for (let j = i + 1; j < segs.length; j++) {
            const a = segs[i];
            const b = segs[j];
            if (a.sid === b.sid || a.sid === b.tid || a.tid === b.sid || a.tid === b.tid) continue;
            const d1x = a.x2 - a.x1;
            const d1y = a.y2 - a.y1;
            const d2x = b.x2 - b.x1;
            const d2y = b.y2 - b.y1;
            const det = d1x * d2y - d1y * d2x;
            if (Math.abs(det) < 0.001) continue;
            const dx = b.x1 - a.x1;
            const dy = b.y1 - a.y1;
            const t = (dx * d2y - dy * d2x) / det;
            const u = (dx * d1y - dy * d1x) / det;
            if (t > 0.02 && t < 0.98 && u > 0.02 && u < 0.98) crossingsEstimate += 1;
          }
        }

        return {
          occupiedBboxPct: Number(occupiedPct.toFixed(2)),
          nodeCountVisible: nodes.length,
          edgeCountVisible: edges.length,
          layerCountsVisible: layerCounts,
          labelCollisions,
          crossingsEstimate,
          canvasW: Math.round(canvasW),
          canvasH: Math.round(canvasH),
          bboxW: Math.round(bbox.w),
          bboxH: Math.round(bbox.h)
        };
      };
    </script>
  </body>
</html>
